<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>堆结构相关操作和堆排序的理解 | 逐东的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">堆结构相关操作和堆排序的理解</h1><a id="logo" href="/.">逐东的博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">堆结构相关操作和堆排序的理解</h1><div class="post-meta">2021-10-08<span> | </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="post-content"><p>总述</p>
<p>​    堆结构是用数组实现的<strong>完全二叉树结构</strong>，其完全二叉树中如果每棵子树的最大值在顶部就是大根堆（根重），最小值在顶部就是小根堆（根轻）；</p>
<p>​    理解堆结构最重要的思想就是它在抽象上是一颗或许具有大根堆\小根堆性质的完全二叉树，而在代码里它是一个数组。这个双重身份是理解堆结构的关键。</p>
<p>​    关于堆的最重要的两个操作就是<strong>heapInsert操作</strong>（数向上浮）和<strong>heapify操作</strong>（数向下落）：</p>
<p>​    以大根堆为例，因为大根堆的规则是头重脚轻，所以当有大的数据在较下面的时候，得<strong>上浮</strong>到二叉树中正确的位置；若有小的数在较上面，得<strong>下落</strong>到二叉树中正确的位置，才能形成大根堆。所以有了此两个操作。小根堆同理。</p>
<p>​    <strong>heapInsert操作</strong>在完全二叉树上的抽象含义就是将要向树尾插入的数据或原本在不正确位置的数据（此数需得上浮）向子树根节点层层向上跃迁到它的值所应该在的位置，以此操作维持此完全二叉树的大/小根堆结构。</p>
<p>​    <strong>heapify操作</strong>在完全二叉树上的抽象含义就是将要向树根插入的数据或原本在不正确位置的数据（此数需得下落）向它的大的孩子层层下落到它的值应该所在的位置，以此操作维持此完全二叉树的大/小根堆结构。</p>
<p>以上讨论了heapInsert与heapify的抽象描述，而在代码层面这两个操作是以操作完全二叉树数组的方式实现的。这些操作皆利用到了完全二叉树映射到数组关系。</p>
<p>​    总述中以完全二叉树抽象方式描述了heapInsert和heapify及堆排序的操作，而在代码层面，关于堆的各种操作是堆构成完全二叉树的数组进行操作来实现的。接下来讨论代码的具体实现。</p>
<h2 id="完全二叉树的数组实现与其节点之间的关系"><a href="#完全二叉树的数组实现与其节点之间的关系" class="headerlink" title="完全二叉树的数组实现与其节点之间的关系"></a>完全二叉树的数组实现与其节点之间的关系</h2><p>若树其中一个节点为在数组上的位置为i</p>
<ul>
<li><p>则其左孩子位置是2*i+1</p>
</li>
<li><p>右孩子位置是2*i+2。</p>
</li>
<li><p>它的爸爸是（int）(i - 1) / 2</p>
<p>所以完全二叉树的数组可以实现时间复杂度为O（1）的随机存取。</p>
</li>
</ul>
<h2 id="heapInsert操作的实现-log-N"><a href="#heapInsert操作的实现-log-N" class="headerlink" title="heapInsert操作的实现(log(N))"></a>heapInsert操作的实现(log(N))</h2><p>heapInsert效果为：当用户一次次在数组最后插入数据时，仍使整个完全二叉树保持大根堆状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> [] arr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123; <span class="comment">//如果插入的数据比其父节点大</span></span><br><span class="line">        swap(arr,index,(index - <span class="number">1</span>) / <span class="number">2</span>);  <span class="comment">//比其父节点大就与父节点交换</span></span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;	     <span class="comment">//然后位置移动到此节点上，继续与其新的父节点相比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码在完全二叉树上的抽象含义流程是：</p>
<ol>
<li><p>在完全二叉树（大根堆）最后插入一个数，若此数比其父节点大，则与父节点交换；</p>
</li>
<li><p>交换后若比父节点大，则继续交换，直到比父节点小为止。</p>
</li>
</ol>
<h2 id="heapiyf操作的实现-log-N"><a href="#heapiyf操作的实现-log-N" class="headerlink" title="heapiyf操作的实现(log(N))"></a>heapiyf操作的实现(log(N))</h2><p>引例：在一个大根堆中，若用户想返回此根堆的最大值，并将其从大根堆移除，移除后让剩下的这些数仍然形成大根堆。</p>
<p>首先，最大值直接用一个变量将arr[0]存储就行。那么如何能将其移除后仍使新数组继续保持大根堆形式呢？</p>
<ol>
<li><strong>将数组中最后一个数复制在大根堆根上</strong>（即复制到arr[0]上，覆盖原来的数，这样原来的数就被移除了），同时**heapSize–**（即这最后一个数被踢出大根堆）</li>
<li>然后从<strong>这个数</strong>（现在在大根堆顶）的<strong>两个孩子里选大的那个孩子</strong>，若<strong>它</strong>这个大孩子比它<strong>大</strong>，则它与这个大孩子<strong>交换</strong>。</li>
<li>交换完<strong>继续找到这个数的新的大孩子</strong>，<strong>若它大孩子比它大</strong>，则交换。</li>
<li>重复3，直到它没孩子，或者它的孩子都比它小，则停止交换。</li>
<li>此时数组为大根堆。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某个数在index位置，能否向下移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//左孩子下标</span></span><br><span class="line">   	<span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//下方还有孩子的时候，循环继续</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; heapSize )&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//两个孩子中谁的值大，把下标给largest</span></span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">    <span class="comment">//父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="comment">//经过上两行代码的折腾，largest下标就是父亲和孩子整个环境中的那个最大值的下标。</span></span><br><span class="line">        <span class="keyword">if</span>(largest == index)&#123; <span class="comment">//这个最大值的下标就是父亲的下标，则父亲停止移动</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果largest不等于index，那么父一定要往下走的。</span></span><br><span class="line">        swap(arr,largest,index);<span class="comment">//父亲和大孩子交换</span></span><br><span class="line">        index = largest;<span class="comment">//此时父亲的下标为它之前大孩子的下标</span></span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//父亲现在的左孩子下标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序的实现"><a href="#堆排序的实现" class="headerlink" title="堆排序的实现"></a>堆排序的实现</h2><p>​    而<strong>堆排序</strong>正与以上两个操作有关。堆排序的抽象实质是：</p>
<p><strong>堆排序简要地讲：</strong></p>
<p>​    将想要排序的杂乱数组形成大根堆；之后把最大的根节点和此时数组最后一个元素交换，这最后一个元素就是排完序的第一个元素（最大），同时大根堆容量-1；重新形成大根堆，把最大根节点和此时数组最后一个元素交换，大根堆容量-1；以此往复，直到大根堆容量=0；此时数组为从小到大排列。</p>
<p><strong>堆排序详细的讲就是：</strong></p>
<ol>
<li>将给定想要排序的数组的每个元素进行heapInsert操作，操作完成后，此数组顺序就<strong>形成了</strong>以完全二叉树为抽象逻辑的<strong>大根堆</strong>；</li>
<li>此时完全二叉树（大根堆）最顶的<strong>根节点</strong>（数组下标为0）的元素就是此数组中<strong>最大值</strong>，将此元素与数组中最后一个元素<strong>交换</strong>，同时规定<strong>heapsize–<strong>；至此，数组中</strong>最大的元素就跑到了原全数组最后一位</strong>，且这个在数组最后一位的最大值数在逻辑上被踢出了大根堆（被踢出了构成根堆的数组，因为heapSize规定被减了1）；</li>
<li>然后对此时的整个树的根节点（最开始的时候数组的最后一位数因为交换跑到了这里）进行heapify操作，于是它向下层层递落到正确的位置，使整个完全二叉树重新形成大根堆；</li>
<li>将重新形成大根堆的根节点（数组中第一个元素）与数组中最后一个元素交换，heapSize–；</li>
<li>重复3,4，操作，直至heapSize &gt; 0 为false（即大根堆中的数全部。</li>
<li>此时，数组为从小到大顺序排列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> [] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">//将数组整理为大根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        heapInsert(arr,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">    <span class="keyword">while</span>(heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">        swap(arr,<span class="number">0</span>,--heaspSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序的扩展题目"><a href="#堆排序的扩展题目" class="headerlink" title="堆排序的扩展题目"></a>堆排序的扩展题目</h2></div><div class="tags"><a href="/cloudtag/%E7%AE%97%E6%B3%95/"><i class="fa fa-tag"></i>算法</a></div><div class="post-nav"><a class="next" href="/2021/09/19/jdbc%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%BF%E6%95%B0%E6%8D%AE%E5%92%8C%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/">jdbc从数据库拿数据和处理的实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%98%B6%E6%AE%B5%E8%A7%84%E5%88%92/">阶段规划</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/cloudtag/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/cloudtag/%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 15px;">方法论</a> <a href="/cloudtag/%E8%80%83%E7%A0%94/" style="font-size: 15px;">考研</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/10/08/algo/heap/">堆结构相关操作和堆排序的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/19/jdbc%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%BF%E6%95%B0%E6%8D%AE%E5%92%8C%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/">jdbc从数据库拿数据和处理的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/18/%E5%AD%A6%E4%B9%A0/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95_4/">学习方法迭代日记_4</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/18/%E5%AD%A6%E4%B9%A0/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/">对学习细节的阶段性复盘与思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/%E5%AD%A6%E4%B9%A0/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95_3/">学习方法迭代日记_3</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/%E5%AD%A6%E4%B9%A0/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95_2/">学习方法迭代日记_2</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/10/%E5%AD%A6%E4%B9%A0/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95_1/">学习方法迭代日记_1</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/09/%E5%AD%A6%E4%B9%A0/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95_0/">学习方法迭代日记_0</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/01/%E5%AD%A6%E4%B9%A0/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%8E%86%E7%A8%8B/">对考研学习的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/30/%E5%AD%A6%E4%B9%A0/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%BF%AD%E4%BB%A3%E8%AE%B0%E5%BD%95/%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92%E4%B9%A6/">考研计划书</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">逐东的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> </a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>